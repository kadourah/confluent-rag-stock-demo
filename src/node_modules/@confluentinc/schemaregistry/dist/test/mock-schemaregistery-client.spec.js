"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const mock_schemaregistry_client_1 = require("../mock-schemaregistry-client");
const schemaregistry_client_1 = require("../schemaregistry-client");
const schemaString = JSON.stringify({
    type: 'record',
    name: 'User',
    fields: [
        { name: 'name', type: 'string' },
        { name: 'age', type: 'int' },
    ],
});
const schemaString2 = JSON.stringify({
    type: 'record',
    name: 'User',
    fields: [
        { name: 'name', type: 'string' },
        { name: 'age', type: 'int' },
        { name: 'email', type: 'string' },
    ],
});
const metadata = {
    properties: {
        owner: 'Alice Bob',
        email: 'alice@bob.com',
    }
};
const metadata2 = {
    properties: {
        owner: 'Alice Bob2',
        email: 'alice@bob2.com'
    }
};
const metadataKeyValue = {
    owner: 'Alice Bob',
    email: 'alice@bob.com'
};
const metadataKeyValue2 = {
    owner: 'Alice Bob2',
    email: 'alice@bob2.com'
};
const schemaInfo = {
    schema: schemaString,
    metadata: metadata
};
const schemaInfo2 = {
    schema: schemaString2,
    metadata: metadata2
};
const testSubject = 'test-subject';
const testSubject2 = 'test-subject2';
(0, globals_1.describe)('MockClient-tests', () => {
    let mockClient;
    (0, globals_1.beforeEach)(() => {
        mockClient = new mock_schemaregistry_client_1.MockClient();
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should return schemaId when calling register', async () => {
        const response = await mockClient.register(testSubject, schemaInfo);
        (0, globals_1.expect)(response).toBe(1);
    });
    (0, globals_1.it)('Should return SchemaMetadata when calling registerFullResponse', async () => {
        const response = await mockClient.registerFullResponse(testSubject, schemaInfo);
        (0, globals_1.expect)(response.id).toBe(1);
    });
    (0, globals_1.it)('Should return SchemaInfo when getting with subject and Id', async () => {
        await mockClient.register(testSubject, schemaInfo);
        const response = await mockClient.getBySubjectAndId(testSubject, 1);
        (0, globals_1.expect)(response.schema).toBe(schemaString);
    });
    (0, globals_1.it)('Should throw error when getBySubjectAndId is called with non-existing schemaId', async () => {
        await mockClient.register(testSubject, schemaInfo);
        await (0, globals_1.expect)(mockClient.getBySubjectAndId(testSubject, 2)).rejects.toThrowError();
    });
    (0, globals_1.it)('Should return schemaId when calling getId', async () => {
        await mockClient.register(testSubject, schemaInfo);
        const response = await mockClient.getId(testSubject, schemaInfo);
        (0, globals_1.expect)(response).toBe(1);
    });
    (0, globals_1.it)('Should throw error when getId is called with non-existing schema', async () => {
        await (0, globals_1.expect)(mockClient.getId(testSubject, schemaInfo)).rejects.toThrowError();
    });
    (0, globals_1.it)('Should return latest schema metadata when calling getLatestSchemaMetadata', async () => {
        await mockClient.register(testSubject, schemaInfo);
        await mockClient.register(testSubject, schemaInfo2);
        const response = await mockClient.getLatestSchemaMetadata(testSubject);
        (0, globals_1.expect)(response.id).toBe(2);
        (0, globals_1.expect)(response.schema).toBe(schemaString2);
    });
    (0, globals_1.it)('Should return latest Schema with metadata when calling getLatestWithMetadata', async () => {
        await mockClient.register(testSubject, schemaInfo);
        await mockClient.register(testSubject, schemaInfo2);
        const response = await mockClient.getLatestWithMetadata(testSubject, metadataKeyValue);
        (0, globals_1.expect)(response.schema).toBe(schemaString);
        (0, globals_1.expect)(response.version).toBe(1);
        const response2 = await mockClient.getLatestWithMetadata(testSubject, metadataKeyValue2);
        (0, globals_1.expect)(response2.schema).toBe(schemaString2);
        (0, globals_1.expect)(response2.version).toBe(2);
    });
    (0, globals_1.it)('Should return specific schemaMetadata version when calling getSchemaMetadata', async () => {
        await mockClient.register(testSubject, schemaInfo);
        await mockClient.register(testSubject, schemaInfo2);
        const response = await mockClient.getSchemaMetadata(testSubject, 1);
        (0, globals_1.expect)(response.id).toBe(1);
        (0, globals_1.expect)(response.schema).toBe(schemaString);
        const response2 = await mockClient.getSchemaMetadata(testSubject, 2);
        (0, globals_1.expect)(response2.id).toBe(2);
        (0, globals_1.expect)(response2.schema).toBe(schemaString2);
    });
    (0, globals_1.it)('Should return the correct version when calling getVersion', async () => {
        await mockClient.register(testSubject, schemaInfo);
        await mockClient.register(testSubject, schemaInfo2);
        const response = await mockClient.getVersion(testSubject, schemaInfo2);
        (0, globals_1.expect)(response).toBe(2);
    });
    (0, globals_1.it)('Should throw error when getVersion is called with non-existing schema', async () => {
        await (0, globals_1.expect)(mockClient.getVersion(testSubject, schemaInfo)).rejects.toThrowError();
    });
    (0, globals_1.it)('Should return all versions when calling getAllVersions', async () => {
        await mockClient.register(testSubject, schemaInfo);
        await mockClient.register(testSubject, schemaInfo2);
        const response = await mockClient.getAllVersions(testSubject);
        (0, globals_1.expect)(response).toEqual([1, 2]);
    });
    (0, globals_1.it)('Should update compatibility when calling updateCompatibility', async () => {
        const response = await mockClient.updateCompatibility(testSubject, schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
        (0, globals_1.expect)(response).toBe(schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
    });
    (0, globals_1.it)('Should return compatibility when calling getCompatibility', async () => {
        await mockClient.updateCompatibility(testSubject, schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
        const response = await mockClient.getCompatibility(testSubject);
        (0, globals_1.expect)(response).toBe(schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
    });
    (0, globals_1.it)('Should throw error when getCompatibility is called with non-existing subject', async () => {
        await (0, globals_1.expect)(mockClient.getCompatibility(testSubject)).rejects.toThrowError();
    });
    (0, globals_1.it)('Should update default compatibility when calling updateDefaultCompatibility', async () => {
        const response = await mockClient.updateDefaultCompatibility(schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
        (0, globals_1.expect)(response).toBe(schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
    });
    (0, globals_1.it)('Should return default compatibility when calling getDefaultCompatibility', async () => {
        await mockClient.updateDefaultCompatibility(schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
        const response = await mockClient.getDefaultCompatibility();
        (0, globals_1.expect)(response).toBe(schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
    });
    (0, globals_1.it)('Should throw error when getDefaultCompatibility is called with non-existing default compatibility', async () => {
        await (0, globals_1.expect)(mockClient.getDefaultCompatibility()).rejects.toThrowError();
    });
    (0, globals_1.it)('Should get all subjects when calling getAllSubjects', async () => {
        (0, globals_1.expect)(await mockClient.getAllSubjects()).toEqual([]);
        await mockClient.register(testSubject, schemaInfo);
        await mockClient.register(testSubject2, schemaInfo);
        const response = await mockClient.getAllSubjects();
        (0, globals_1.expect)(response).toEqual([testSubject, testSubject2]);
    });
    (0, globals_1.it)('Should soft delete subject when calling deleteSubject', async () => {
        await mockClient.register(testSubject, schemaInfo);
        await mockClient.deleteSubject(testSubject);
        await (0, globals_1.expect)(mockClient.getId(testSubject, schemaInfo)).rejects.toThrowError();
        await (0, globals_1.expect)(mockClient.getVersion(testSubject, schemaInfo)).rejects.toThrowError();
        const response = await mockClient.getBySubjectAndId(testSubject, 1);
        await (0, globals_1.expect)(response.schema).toBe(schemaString);
    });
    (0, globals_1.it)('Should permanent delete subject when calling deleteSubject with permanent flag', async () => {
        await mockClient.register(testSubject, schemaInfo);
        await mockClient.deleteSubject(testSubject, true);
        await (0, globals_1.expect)(mockClient.getId(testSubject, schemaInfo)).rejects.toThrowError();
        await (0, globals_1.expect)(mockClient.getVersion(testSubject, schemaInfo)).rejects.toThrowError();
        await (0, globals_1.expect)(mockClient.getBySubjectAndId(testSubject, 1)).rejects.toThrowError();
    });
    (0, globals_1.it)('Should soft delete subject version when calling deleteSubjectVersion', async () => {
        await mockClient.register(testSubject, schemaInfo);
        await mockClient.register(testSubject, schemaInfo2);
        await mockClient.deleteSubjectVersion(testSubject, 1);
        await (0, globals_1.expect)(mockClient.getId(testSubject, schemaInfo)).rejects.toThrowError();
        await (0, globals_1.expect)(mockClient.getVersion(testSubject, schemaInfo)).rejects.toThrowError();
        const response = await mockClient.getBySubjectAndId(testSubject, 1);
        await (0, globals_1.expect)(response.schema).toBe(schemaString);
        const response2 = await mockClient.getBySubjectAndId(testSubject, 2);
        await (0, globals_1.expect)(response2.schema).toBe(schemaString2);
    });
});
