"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
exports.__esModule = true;
exports.mergeReferenceInto = void 0;
function mergeReferenceInto(target, referencedSchema, siblings, policy) {
    var mergeReferencedSchemaByKeyword = function () {
        Object.assign(target, siblings);
        // This implementation will either merge referencedSchema's keywords alongside target,
        // unless there is a conflict between keywords (with some exceptions).
        // If there is a conflict, then referencedSchema will remain under the $ref keyword,
        // but dereferenced.
        // This assumes that all keywords are independent and don't interact with each other.
        var targetKeywords = Object.keys(target);
        var referencedKeywords = Object.keys(referencedSchema).filter(function (keyword) {
            // $id doesn't count as a conflict if we're going to merge the referenced schema
            if (keyword === '$id') {
                return false;
            }
            // $defs doesn't count as a conflict if we're going to merge the referenced schema
            if (keyword === '$defs' || keyword === 'definitions') {
                return false;
            }
            // keyword doesn't count as a conflict if they are the same value
            if (referencedSchema[keyword] === target[keyword]) {
                return false;
            }
            return true;
        });
        var hasConflictingKeywords = targetKeywords.some(function (keyword) { return referencedKeywords.includes(keyword); });
        if (hasConflictingKeywords) {
            target['$ref'] = referencedSchema;
        }
        else {
            // Since no keywords appear in both, merge schemas into one as in draft 04.
            var siblings_1 = __rest(target, []);
            Object.assign(target, referencedSchema, siblings_1);
        }
    };
    switch (policy) {
        case 'by_keyword':
            mergeReferencedSchemaByKeyword();
            break;
        case 'overwrite':
            // ignore siblings
            Object.assign(target, referencedSchema);
            break;
        case 'none':
            Object.assign(target, siblings);
            target['$ref'] = referencedSchema;
            break;
        case 'default':
        default:
            mergeReferencedSchemaByKeyword();
            break;
    }
}
exports.mergeReferenceInto = mergeReferenceInto;
