"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dekregistry_client_1 = require("../../rules/encryption/dekregistry/dekregistry-client");
const rest_service_1 = require("../../rest-service");
const globals_1 = require("@jest/globals");
const test_constants_1 = require("./test-constants");
const test_constants_2 = require("../test-constants");
globals_1.jest.mock('../../rest-service');
let client;
let restService;
(0, globals_1.describe)('DekRegistryClient', () => {
    (0, globals_1.beforeEach)(() => {
        restService = new rest_service_1.RestService(test_constants_2.mockClientConfig.baseURLs);
        client = new dekregistry_client_1.DekRegistryClient(test_constants_2.mockClientConfig);
        client.restService = restService;
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should register kek when registerKek is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_KEK });
        const response = await client.registerKek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_KMS_TYPE, test_constants_1.TEST_KMS_KEY_ID, true, test_constants_1.TEST_KMS_PROPS, test_constants_1.TEST_DOC);
        (0, globals_1.expect)(response).toEqual(test_constants_1.TEST_KEK);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return kek from cache when registerKek is called with same kek name', async () => {
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_KEK });
        await client.registerKek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_KMS_TYPE, test_constants_1.TEST_KMS_KEY_ID, true, test_constants_1.TEST_KMS_PROPS, test_constants_1.TEST_DOC);
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_KEK_2 });
        await client.registerKek(test_constants_1.TEST_KEK_NAME_2, test_constants_1.TEST_KMS_TYPE, test_constants_1.TEST_KMS_KEY_ID, true, test_constants_1.TEST_KMS_PROPS, test_constants_1.TEST_DOC);
        const response = await client.registerKek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_KMS_TYPE, test_constants_1.TEST_KMS_KEY_ID, true, test_constants_1.TEST_KMS_PROPS, test_constants_1.TEST_DOC);
        const response2 = await client.registerKek(test_constants_1.TEST_KEK_NAME_2, test_constants_1.TEST_KMS_TYPE, test_constants_1.TEST_KMS_KEY_ID, true, test_constants_1.TEST_KMS_PROPS, test_constants_1.TEST_DOC);
        (0, globals_1.expect)(response).toEqual(test_constants_1.TEST_KEK);
        (0, globals_1.expect)(response2).toEqual(test_constants_1.TEST_KEK_2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
    (0, globals_1.it)('Should return kek from cache when getKek is called with same kek name', async () => {
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_KEK });
        await client.registerKek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_KMS_TYPE, test_constants_1.TEST_KMS_KEY_ID, true, test_constants_1.TEST_KMS_PROPS, test_constants_1.TEST_DOC);
        const response = await client.getKek(test_constants_1.TEST_KEK_NAME);
        (0, globals_1.expect)(response).toEqual(test_constants_1.TEST_KEK);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should register dek when registerDek is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_DEK });
        const response = await client.registerDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        (0, globals_1.expect)(response).toEqual(test_constants_1.TEST_DEK);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return dek from cache when registerDek is called with same kek name, subject, algorithm, and version', async () => {
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_DEK });
        await client.registerDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_DEK_2 });
        await client.registerDek(test_constants_1.TEST_KEK_NAME_2, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        const response = await client.registerDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        const response2 = await client.registerDek(test_constants_1.TEST_KEK_NAME_2, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        (0, globals_1.expect)(response).toEqual(test_constants_1.TEST_DEK);
        (0, globals_1.expect)(response2).toEqual(test_constants_1.TEST_DEK_2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
    (0, globals_1.it)('Should return dek from cache when getDek is called with same kek name, subject, algorithm, and version', async () => {
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_DEK });
        await client.registerDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        const response = await client.getDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION);
        (0, globals_1.expect)(response).toEqual(test_constants_1.TEST_DEK);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should delete dek with version -1 when registerDek is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_DEK_LATEST });
        const getDekResponse = await client.getDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, -1);
        (0, globals_1.expect)(getDekResponse).toEqual(test_constants_1.TEST_DEK_LATEST);
        (0, globals_1.expect)(await client.checkLatestDekInCache(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM)).toBe(true);
        restService.handleRequest.mockResolvedValue({ data: test_constants_1.TEST_DEK });
        await client.registerDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        const getDekResponse2 = await client.getDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM);
        (0, globals_1.expect)(getDekResponse2).toEqual(test_constants_1.TEST_DEK);
        (0, globals_1.expect)(await client.checkLatestDekInCache(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM)).toBe(false);
    });
});
