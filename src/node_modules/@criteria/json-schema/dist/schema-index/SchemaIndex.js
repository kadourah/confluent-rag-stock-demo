"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
exports.__esModule = true;
exports.SchemaIndex = void 0;
var json_pointer_1 = require("@criteria/json-pointer");
var DocumentIndex_1 = require("../schema-index/DocumentIndex");
var JSONReferenceContentIndex_1 = require("../schema-index/JSONReferenceContentIndex");
var SchemaContentIndex_1 = require("../schema-index/SchemaContentIndex");
var promises_1 = require("../util/promises");
var uri_1 = require("../util/uri");
var SchemaIndex = /** @class */ (function (_super) {
    __extends(SchemaIndex, _super);
    function SchemaIndex(configuration) {
        var _this = _super.call(this, {
            cloned: configuration.cloned,
            retrieve: configuration.retrieve
        }) || this;
        _this.references = new Map();
        _this.schemaContentIndex = new SchemaContentIndex_1.SchemaContentIndex();
        _this.jsonReferenceContentIndex = new JSONReferenceContentIndex_1.JSONReferenceContentIndex({
            shouldIndexObject: function (object) {
                // don't index as JSON Reference if already indexed as schema or document
                return !_this.isObjectIndexed(object);
            }
        });
        _this.defaultMetaSchemaID = configuration.defaultMetaSchemaID;
        return _this;
    }
    SchemaIndex.prototype.isObjectIndexed = function (object) {
        if (this.schemaContentIndex.isObjectIndexed(object)) {
            return true;
        }
        if (this.jsonReferenceContentIndex.isObjectIndexed(object)) {
            return true;
        }
        return _super.prototype.isObjectIndexed.call(this, object);
    };
    SchemaIndex.prototype.isURIIndexed = function (uri) {
        if (this.schemaContentIndex.isURIIndexed(uri)) {
            return true;
        }
        if (this.jsonReferenceContentIndex.isURIIndexed(uri)) {
            return true;
        }
        return _super.prototype.indexedObjectWithURI.call(this, uri);
    };
    SchemaIndex.prototype.indexedObjectWithURI = function (uri) {
        if (this.schemaContentIndex.isURIIndexed(uri)) {
            return this.schemaContentIndex.indexedObjectWithURI(uri);
        }
        if (this.jsonReferenceContentIndex.isURIIndexed(uri)) {
            return this.jsonReferenceContentIndex.indexedObjectWithURI(uri);
        }
        return _super.prototype.indexedObjectWithURI.call(this, uri);
    };
    SchemaIndex.prototype.infoForIndexedObject = function (object) {
        if (this.schemaContentIndex.isObjectIndexed(object)) {
            return this.schemaContentIndex.infoForIndexedObject(object);
        }
        if (this.jsonReferenceContentIndex.isObjectIndexed(object)) {
            return this.jsonReferenceContentIndex.infoForIndexedObject(object);
        }
        return _super.prototype.infoForIndexedObject.call(this, object);
    };
    SchemaIndex.prototype.dereferenceReference = function (uri, reference, schemaPath) {
        var _a;
        var resolvedURI = (_a = this.references.get(reference)) === null || _a === void 0 ? void 0 : _a.resolvedURI;
        return this.find(resolvedURI, { followReferences: false });
    };
    SchemaIndex.prototype.dereferenceDynamicReference = function (uri, dynamicReference, schemaPath) {
        var e_1, _a;
        var _b, _c, _d;
        var resolvedURI = (_b = this.references.get(dynamicReference)) === null || _b === void 0 ? void 0 : _b.resolvedURI;
        var dereferencedSchema = this.find(resolvedURI, { followReferences: false });
        // A $dynamicRef without anchor in fragment behaves identical to $ref
        if ((0, json_pointer_1.isJSONPointer)((0, uri_1.splitFragment)(resolvedURI).fragment)) {
            return dereferencedSchema;
        }
        var root = this.root();
        var candidate = root;
        try {
            for (var schemaPath_1 = __values(schemaPath), schemaPath_1_1 = schemaPath_1.next(); !schemaPath_1_1.done; schemaPath_1_1 = schemaPath_1.next()) {
                var jsonPointer = schemaPath_1_1.value;
                candidate = (0, json_pointer_1.evaluateJSONPointer)(jsonPointer, candidate);
                if (jsonPointer === '/$ref' && typeof candidate === 'string') {
                    var baseURI = this.infoForIndexedObject(dynamicReference).baseURI;
                    var uri_2 = (0, uri_1.resolveURIReference)(candidate, baseURI);
                    candidate = this.find(uri_2, { followReferences: false });
                }
                if (typeof candidate !== 'object') {
                    continue;
                }
                if ('$dynamicAnchor' in candidate && candidate.$dynamicAnchor === dereferencedSchema.$dynamicAnchor) {
                    return candidate;
                }
                if ('$id' in candidate && typeof candidate.$id === 'string') {
                    var outermostBaseURI = (_d = ((_c = this.infoForIndexedObject(candidate)) !== null && _c !== void 0 ? _c : this.infoForIndexedObject(root))) === null || _d === void 0 ? void 0 : _d.baseURI;
                    var outermostURI = (0, uri_1.resolveURIReference)(candidate.$id, outermostBaseURI);
                    var anchorURI = (0, uri_1.resolveURIReference)("#".concat(dereferencedSchema.$dynamicAnchor), outermostURI);
                    var candidateAnchor = this.find(anchorURI, { followReferences: false });
                    if (candidateAnchor) {
                        // An $anchor with the same name as a $dynamicAnchor is not used for dynamic scope resolution
                        if (typeof candidateAnchor === 'object' &&
                            '$dynamicAnchor' in candidateAnchor &&
                            candidateAnchor.$dynamicAnchor === dereferencedSchema.$dynamicAnchor) {
                            return candidateAnchor;
                        }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (schemaPath_1_1 && !schemaPath_1_1.done && (_a = schemaPath_1["return"])) _a.call(schemaPath_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return dereferencedSchema;
    };
    SchemaIndex.prototype.addRootSchema = function (rootSchema, baseURI) {
        var _this = this;
        rootSchema = this.addDocument(rootSchema, baseURI);
        var rootSchemaMetadata = {
            metaSchemaID: this.defaultMetaSchemaID
        };
        var addSchemasResult = this.addSchemas(rootSchema, baseURI, rootSchemaMetadata);
        return (0, promises_1.chain)(addSchemasResult, function () {
            return _this.addJSONReferences(rootSchema, baseURI, rootSchemaMetadata);
        });
    };
    SchemaIndex.prototype.addSchemas = function (rootSchema, baseURI, metadata) {
        var _this = this;
        var foundSchemaReferences = this.schemaContentIndex.addContentFromRoot(rootSchema, baseURI, metadata);
        foundSchemaReferences.forEach(function (info, reference) {
            _this.references.set(reference, info);
        });
        return (0, promises_1.chainForEach)(foundSchemaReferences.values(), function (info) {
            if (_this.isURIIndexed(info.resolvedURI)) {
                return;
            }
            var _a = (0, uri_1.splitFragment)(info.resolvedURI), absoluteURI = _a.absoluteURI, fragment = _a.fragment;
            var documentOrPromise;
            if (_this.isURIIndexed(absoluteURI)) {
                documentOrPromise = _this.indexedObjectWithURI(absoluteURI);
            }
            else {
                documentOrPromise = _this.addDocumentWithURI(absoluteURI);
            }
            return (0, promises_1.chain)(documentOrPromise, function (document) {
                if (document) {
                    if (fragment && (0, json_pointer_1.isJSONPointer)(fragment)) {
                        var rootObject_1 = (0, json_pointer_1.evaluateJSONPointer)(fragment, document);
                        if (rootObject_1) {
                            var addSchemasResult = _this.addSchemas(rootObject_1, info.resolvedURI, info.metadata);
                            return (0, promises_1.chain)(addSchemasResult, function () {
                                return _this.addJSONReferences(rootObject_1, info.resolvedURI, info.metadata);
                            });
                        }
                    }
                    else {
                        var addSchemasResult = _this.addSchemas(document, absoluteURI, info.metadata);
                        return (0, promises_1.chain)(addSchemasResult, function () {
                            return _this.addJSONReferences(document, absoluteURI, info.metadata);
                        });
                    }
                }
            });
        });
    };
    SchemaIndex.prototype.addJSONReferences = function (rootObject, baseURI, metadata) {
        var _this = this;
        var foundJSONReferences = this.jsonReferenceContentIndex.addContentFromRoot(rootObject, baseURI, metadata);
        foundJSONReferences.forEach(function (info, reference) {
            _this.references.set(reference, info);
        });
        return (0, promises_1.chainForEach)(foundJSONReferences.values(), function (info) {
            if (_this.isURIIndexed(info.resolvedURI)) {
                return;
            }
            var _a = (0, uri_1.splitFragment)(info.resolvedURI), absoluteURI = _a.absoluteURI, fragment = _a.fragment;
            var documentOrPromise;
            if (!_this.isURIIndexed(absoluteURI)) {
                documentOrPromise = _this.addDocumentWithURI(absoluteURI);
            }
            return (0, promises_1.chain)(documentOrPromise, function (document) {
                if (document) {
                    if (fragment && (0, json_pointer_1.isJSONPointer)(fragment)) {
                        var rootObject_2 = (0, json_pointer_1.evaluateJSONPointer)(fragment, document);
                        if (rootObject_2) {
                            return _this.addJSONReferences(rootObject_2, info.resolvedURI, info.metadata);
                        }
                    }
                    else {
                        return _this.addJSONReferences(document, absoluteURI, info.metadata);
                    }
                }
            });
        });
    };
    return SchemaIndex;
}(DocumentIndex_1.DocumentIndex));
exports.SchemaIndex = SchemaIndex;
