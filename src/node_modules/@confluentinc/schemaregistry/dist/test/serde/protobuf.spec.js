"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const protobuf_1 = require("../../serde/protobuf");
const serde_1 = require("../../serde/serde");
const schemaregistry_client_1 = require("../../schemaregistry-client");
const local_driver_1 = require("../../rules/encryption/localkms/local-driver");
const encrypt_executor_1 = require("../../rules/encryption/encrypt-executor");
const example_pb_1 = require("./test/example_pb");
const protobuf_2 = require("@bufbuild/protobuf");
const wkt_1 = require("@bufbuild/protobuf/wkt");
const nested_pb_1 = require("./test/nested_pb");
const test_pb_1 = require("./test/test_pb");
const dep_pb_1 = require("./test/dep_pb");
const rule_registry_1 = require("@confluentinc/schemaregistry/serde/rule-registry");
const cycle_pb_1 = require("./test/cycle_pb");
const kms_registry_1 = require("@confluentinc/schemaregistry/rules/encryption/kms-registry");
const fieldEncryptionExecutor = encrypt_executor_1.FieldEncryptionExecutor.register();
local_driver_1.LocalKmsDriver.register();
//const baseURL = 'http://localhost:8081'
const baseURL = 'mock://';
const topic = 'topic1';
const subject = topic + '-value';
(0, globals_1.describe)('ProtobufSerializer', () => {
    (0, globals_1.afterEach)(async () => {
        let conf = {
            baseURLs: [baseURL],
            cacheCapacity: 1000
        };
        let client = schemaregistry_client_1.SchemaRegistryClient.newClient(conf);
        await client.deleteSubject(subject, false);
        await client.deleteSubject(subject, true);
    });
    (0, globals_1.it)('basic serialization', async () => {
        let conf = {
            baseURLs: [baseURL],
            cacheCapacity: 1000
        };
        let client = schemaregistry_client_1.SchemaRegistryClient.newClient(conf);
        let ser = new protobuf_1.ProtobufSerializer(client, serde_1.SerdeType.VALUE, { autoRegisterSchemas: true });
        ser.registry.add(example_pb_1.AuthorSchema);
        let obj = (0, protobuf_2.create)(example_pb_1.AuthorSchema, {
            name: 'Kafka',
            id: 123,
            picture: Buffer.from([1, 2]),
            works: ['The Castle', 'The Trial']
        });
        let bytes = await ser.serialize(topic, obj);
        let deser = new protobuf_1.ProtobufDeserializer(client, serde_1.SerdeType.VALUE, {});
        let obj2 = await deser.deserialize(topic, bytes);
        (0, globals_1.expect)(obj2).toEqual(obj);
    });
    (0, globals_1.it)('serialize second messsage', async () => {
        let conf = {
            baseURLs: [baseURL],
            cacheCapacity: 1000
        };
        let client = schemaregistry_client_1.SchemaRegistryClient.newClient(conf);
        let ser = new protobuf_1.ProtobufSerializer(client, serde_1.SerdeType.VALUE, { autoRegisterSchemas: true });
        ser.registry.add(example_pb_1.PizzaSchema);
        let obj = (0, protobuf_2.create)(example_pb_1.PizzaSchema, {
            size: 'Extra extra large',
            toppings: ['anchovies', 'mushrooms']
        });
        let bytes = await ser.serialize(topic, obj);
        let deser = new protobuf_1.ProtobufDeserializer(client, serde_1.SerdeType.VALUE, {});
        let obj2 = await deser.deserialize(topic, bytes);
        (0, globals_1.expect)(obj2).toEqual(obj);
    });
    (0, globals_1.it)('serialize nested messsage', async () => {
        let conf = {
            baseURLs: [baseURL],
            cacheCapacity: 1000
        };
        let client = schemaregistry_client_1.SchemaRegistryClient.newClient(conf);
        let ser = new protobuf_1.ProtobufSerializer(client, serde_1.SerdeType.VALUE, { autoRegisterSchemas: true });
        ser.registry.add(nested_pb_1.NestedMessage_InnerMessageSchema);
        let obj = (0, protobuf_2.create)(nested_pb_1.NestedMessage_InnerMessageSchema, {
            id: "inner"
        });
        let bytes = await ser.serialize(topic, obj);
        let deser = new protobuf_1.ProtobufDeserializer(client, serde_1.SerdeType.VALUE, {});
        let obj2 = await deser.deserialize(topic, bytes);
        (0, globals_1.expect)(obj2).toEqual(obj);
    });
    (0, globals_1.it)('serialize reference', async () => {
        let conf = {
            baseURLs: [baseURL],
            cacheCapacity: 1000
        };
        let client = schemaregistry_client_1.SchemaRegistryClient.newClient(conf);
        let ser = new protobuf_1.ProtobufSerializer(client, serde_1.SerdeType.VALUE, { autoRegisterSchemas: true });
        ser.registry.add(test_pb_1.TestMessageSchema);
        ser.registry.add(dep_pb_1.DependencyMessageSchema);
        let msg = (0, protobuf_2.create)(test_pb_1.TestMessageSchema, {
            testString: "hi",
            testBool: true,
            testBytes: Buffer.from([1, 2]),
            testDouble: 1.23,
            testFloat: 3.45,
            testFixed32: 67,
            testFixed64: 89n,
            testInt32: 100,
            testInt64: 200n,
            testSfixed32: 300,
            testSfixed64: 400n,
            testSint32: 500,
            testSint64: 600n,
            testUint32: 700,
            testUint64: 800n,
        });
        let obj = (0, protobuf_2.create)(dep_pb_1.DependencyMessageSchema, {
            isActive: true,
            testMesssage: msg
        });
        let bytes = await ser.serialize(topic, obj);
        let deser = new protobuf_1.ProtobufDeserializer(client, serde_1.SerdeType.VALUE, {});
        let obj2 = await deser.deserialize(topic, bytes);
        (0, globals_1.expect)(obj2.testMesssage.testString).toEqual(msg.testString);
        (0, globals_1.expect)(obj2.testMesssage.testBool).toEqual(msg.testBool);
        (0, globals_1.expect)(obj2.testMesssage.testBytes).toEqual(msg.testBytes);
        (0, globals_1.expect)(obj2.testMesssage.testDouble).toBeCloseTo(msg.testDouble, 0.001);
        (0, globals_1.expect)(obj2.testMesssage.testFloat).toBeCloseTo(msg.testFloat, 0.001);
        (0, globals_1.expect)(obj2.testMesssage.testFixed32).toEqual(msg.testFixed32);
        (0, globals_1.expect)(obj2.testMesssage.testFixed64).toEqual(msg.testFixed64);
    });
    (0, globals_1.it)('serialize cycle', async () => {
        let conf = {
            baseURLs: [baseURL],
            cacheCapacity: 1000
        };
        let client = schemaregistry_client_1.SchemaRegistryClient.newClient(conf);
        let ser = new protobuf_1.ProtobufSerializer(client, serde_1.SerdeType.VALUE, { autoRegisterSchemas: true });
        ser.registry.add(cycle_pb_1.LinkedListSchema);
        let inner = (0, protobuf_2.create)(cycle_pb_1.LinkedListSchema, {
            value: 100,
        });
        let obj = (0, protobuf_2.create)(cycle_pb_1.LinkedListSchema, {
            value: 1,
            next: inner
        });
        let bytes = await ser.serialize(topic, obj);
        let deser = new protobuf_1.ProtobufDeserializer(client, serde_1.SerdeType.VALUE, {});
        let obj2 = await deser.deserialize(topic, bytes);
        (0, globals_1.expect)(obj2).toEqual(obj);
    });
    (0, globals_1.it)('basic encryption', async () => {
        let conf = {
            baseURLs: [baseURL],
            cacheCapacity: 1000
        };
        let client = schemaregistry_client_1.SchemaRegistryClient.newClient(conf);
        let serConfig = {
            useLatestVersion: true,
            ruleConfig: {
                secret: 'mysecret'
            }
        };
        let ser = new protobuf_1.ProtobufSerializer(client, serde_1.SerdeType.VALUE, serConfig);
        ser.registry.add(example_pb_1.AuthorSchema);
        let dekClient = fieldEncryptionExecutor.client;
        let encRule = {
            name: 'test-encrypt',
            kind: 'TRANSFORM',
            mode: schemaregistry_client_1.RuleMode.WRITEREAD,
            type: 'ENCRYPT',
            tags: ['PII'],
            params: {
                'encrypt.kek.name': 'kek1',
                'encrypt.kms.type': 'local-kms',
                'encrypt.kms.key.id': 'mykey',
            },
            onFailure: 'ERROR,NONE'
        };
        let ruleSet = {
            domainRules: [encRule]
        };
        let info = {
            schemaType: 'PROTOBUF',
            schema: Buffer.from((0, protobuf_2.toBinary)(wkt_1.FileDescriptorProtoSchema, example_pb_1.file_test_schemaregistry_serde_example.proto)).toString('base64'),
            ruleSet
        };
        await client.register(subject, info, false);
        let obj = (0, protobuf_2.create)(example_pb_1.AuthorSchema, {
            name: 'Kafka',
            id: 123,
            picture: Buffer.from([1, 2]),
            works: ['The Castle', 'The Trial']
        });
        let bytes = await ser.serialize(topic, obj);
        // reset encrypted field
        obj.name = 'Kafka';
        obj.picture = Buffer.from([1, 2]);
        let deserConfig = {
            ruleConfig: {
                secret: 'mysecret'
            }
        };
        let deser = new protobuf_1.ProtobufDeserializer(client, serde_1.SerdeType.VALUE, deserConfig);
        fieldEncryptionExecutor.client = dekClient;
        let obj2 = await deser.deserialize(topic, bytes);
        (0, globals_1.expect)(obj2).toEqual(obj);
        (0, kms_registry_1.clearKmsClients)();
        let registry = new rule_registry_1.RuleRegistry();
        registry.registerExecutor(new encrypt_executor_1.FieldEncryptionExecutor());
        deser = new protobuf_1.ProtobufDeserializer(client, serde_1.SerdeType.VALUE, {}, registry);
        obj2 = await deser.deserialize(topic, bytes);
        (0, globals_1.expect)(obj2).not.toEqual(obj);
    });
});
