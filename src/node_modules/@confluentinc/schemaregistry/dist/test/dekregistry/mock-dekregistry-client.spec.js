"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mock_dekregistry_client_1 = require("../../rules/encryption/dekregistry/mock-dekregistry-client");
const globals_1 = require("@jest/globals");
const test_constants_1 = require("./test-constants");
(0, globals_1.describe)('MockClient-tests', () => {
    let mockClient;
    (0, globals_1.beforeEach)(() => {
        mockClient = new mock_dekregistry_client_1.MockDekRegistryClient();
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should return kek when registering Kek', async () => {
        const registerKekResponse = await mockClient.registerKek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_KMS_TYPE, test_constants_1.TEST_KMS_KEY_ID, true, test_constants_1.TEST_KMS_PROPS, test_constants_1.TEST_DOC);
        (0, globals_1.expect)(registerKekResponse).toEqual(test_constants_1.TEST_KEK);
    });
    (0, globals_1.it)('Should return kek when getting Kek', async () => {
        await mockClient.registerKek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_KMS_TYPE, test_constants_1.TEST_KMS_KEY_ID, true, test_constants_1.TEST_KMS_PROPS, test_constants_1.TEST_DOC);
        const getKekResponse = await mockClient.getKek(test_constants_1.TEST_KEK_NAME);
        (0, globals_1.expect)(getKekResponse).toEqual(test_constants_1.TEST_KEK);
    });
    (0, globals_1.it)('Should return dek when registering Dek', async () => {
        const registerDekResponse = await mockClient.registerDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        (0, globals_1.expect)(registerDekResponse).toEqual(test_constants_1.TEST_DEK);
    });
    (0, globals_1.it)('Should return dek when getting Dek', async () => {
        await mockClient.registerDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        const getDekResponse = await mockClient.getDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION);
        (0, globals_1.expect)(getDekResponse).toEqual(test_constants_1.TEST_DEK);
    });
    (0, globals_1.it)('Should return latest dek when getting Dek with version -1', async () => {
        await mockClient.registerDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, 2, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        await mockClient.registerDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, test_constants_1.TEST_VERSION, test_constants_1.TEST_ENCRYPTED_KEY_MATERIAL);
        const getDekResponse = await mockClient.getDek(test_constants_1.TEST_KEK_NAME, test_constants_1.TEST_SUBJECT, test_constants_1.TEST_ALGORITHM, -1);
        (0, globals_1.expect)(getDekResponse).toEqual(test_constants_1.TEST_DEK_V2);
    });
});
