"use strict";
var __awaiter = this && this.__awaiter || (function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
});
Object.defineProperty(exports, "__esModule", {
  value: true
});
const block_1 = require("../../internals/block.dist.cjs");
class SoftAesCtr {
  constructor(cipher) {
    this._cipher = cipher;
    this._counter = new block_1.default();
    this._buffer = new block_1.default();
  }
  clear() {
    this._buffer.clear();
    this._counter.clear();
    this._cipher.clear();
    return this;
  }
  encryptCtr(iv, plaintext) {
    return __awaiter(this, void 0, void 0, function* () {
      if (iv.length !== block_1.default.SIZE) {
        throw new Error("CTR: iv length must be equal to cipher block size");
      }
      this._counter.data.set(iv);
      let bufferPos = block_1.default.SIZE;
      const result = new Uint8Array(plaintext.length);
      for (let i = 0; i < plaintext.length; i++) {
        if (bufferPos === block_1.default.SIZE) {
          this._buffer.copy(this._counter);
          this._cipher.encryptBlock(this._buffer);
          bufferPos = 0;
          incrementCounter(this._counter);
        }
        result[i] = plaintext[i] ^ this._buffer.data[bufferPos++];
      }
      return result;
    });
  }
}
exports.default = SoftAesCtr;
function incrementCounter(counter) {
  let carry = 1;
  for (let i = block_1.default.SIZE - 1; i >= 0; i--) {
    carry += counter.data[i] & 0xff | 0;
    counter.data[i] = carry & 0xff;
    carry >>>= 8;
  }
}
