"use strict";
var __awaiter = this && this.__awaiter || (function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
});
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CMAC = void 0;
const block_1 = require("../internals/block.dist.cjs");
const xor_1 = require("../internals/xor.dist.cjs");
class CMAC {
  static importKey(provider, keyData) {
    return __awaiter(this, void 0, void 0, function* () {
      const cipher = yield provider.importBlockCipherKey(keyData);
      const subkey1 = new block_1.default();
      yield cipher.encryptBlock(subkey1);
      subkey1.dbl();
      const subkey2 = subkey1.clone();
      subkey2.dbl();
      return new CMAC(cipher, subkey1, subkey2);
    });
  }
  constructor(_cipher, _subkey1, _subkey2) {
    this._cipher = _cipher;
    this._subkey1 = _subkey1;
    this._subkey2 = _subkey2;
    this._bufferPos = 0;
    this._finished = false;
    this._buffer = new block_1.default();
  }
  reset() {
    this._buffer.clear();
    this._bufferPos = 0;
    this._finished = false;
    return this;
  }
  clear() {
    this.reset();
    this._subkey1.clear();
    this._subkey2.clear();
  }
  update(data) {
    return __awaiter(this, void 0, void 0, function* () {
      const left = block_1.default.SIZE - this._bufferPos;
      let dataPos = 0;
      let dataLength = data.length;
      if (dataLength > left) {
        for (let i = 0; i < left; i++) {
          this._buffer.data[this._bufferPos + i] ^= data[i];
        }
        dataLength -= left;
        dataPos += left;
        yield this._cipher.encryptBlock(this._buffer);
        this._bufferPos = 0;
      }
      while (dataLength > block_1.default.SIZE) {
        for (let i = 0; i < block_1.default.SIZE; i++) {
          this._buffer.data[i] ^= data[dataPos + i];
        }
        dataLength -= block_1.default.SIZE;
        dataPos += block_1.default.SIZE;
        yield this._cipher.encryptBlock(this._buffer);
      }
      for (let i = 0; i < dataLength; i++) {
        this._buffer.data[this._bufferPos++] ^= data[dataPos + i];
      }
      return this;
    });
  }
  finish() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this._finished) {
        const subkey = this._bufferPos < block_1.default.SIZE ? this._subkey2 : this._subkey1;
        (0, xor_1.xor)(this._buffer.data, subkey.data);
        if (this._bufferPos < block_1.default.SIZE) {
          this._buffer.data[this._bufferPos] ^= 0x80;
        }
        yield this._cipher.encryptBlock(this._buffer);
        this._finished = true;
      }
      return this._buffer.clone().data;
    });
  }
}
exports.CMAC = CMAC;
