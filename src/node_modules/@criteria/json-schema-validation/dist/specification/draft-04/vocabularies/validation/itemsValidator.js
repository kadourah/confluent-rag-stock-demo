"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.formatMessage = exports.itemsValidator = void 0;
var formatList_1 = require("../../../../util/formatList");
var isJSONArray_1 = require("../../../../util/isJSONArray");
function itemsValidator(schema, schemaPath, context) {
    if (!('items' in schema)) {
        return null;
    }
    var items = schema['items'];
    if (Array.isArray(items)) {
        var itemValidators_1 = items.map(function (subschema, i) {
            return context.validatorForSchema(subschema, __spreadArray(__spreadArray([], __read(schemaPath), false), ["/items/".concat(i)], false));
        });
        var outputFormat_1 = context.outputFormat;
        var failFast_1 = context.failFast;
        var schemaLocation_1 = schemaPath.join('');
        return function (instance, instanceLocation, annotationResults) {
            if (!(0, isJSONArray_1.isJSONArray)(instance)) {
                return { valid: true, schemaLocation: schemaLocation_1, instanceLocation: instanceLocation };
            }
            var validOutputs = [];
            var errors = [];
            var invalidIndices = [];
            for (var i = 0; i < instance.length && i < itemValidators_1.length; i++) {
                var validator = itemValidators_1[i];
                var output = validator(instance[i], "".concat(instanceLocation, "/").concat(i));
                if (output.valid) {
                    validOutputs.push(output);
                }
                else {
                    if (failFast_1) {
                        return output;
                    }
                    invalidIndices.push(i);
                    errors.push(output);
                }
            }
            if (errors.length === 0) {
                return {
                    valid: true,
                    schemaLocation: schemaLocation_1,
                    schemaKeyword: 'items',
                    instanceLocation: instanceLocation,
                    annotationResults: {
                        items: validOutputs.length < instance.length ? validOutputs.length - 1 : true
                    }
                };
            }
            else {
                if (outputFormat_1 === 'flag') {
                    return { valid: false };
                }
                else {
                    return {
                        valid: false,
                        schemaLocation: schemaLocation_1,
                        schemaKeyword: 'items',
                        instanceLocation: instanceLocation,
                        message: formatMessage(errors, invalidIndices),
                        errors: errors
                    };
                }
            }
        };
    }
    else {
        var validator_1 = context.validatorForSchema(items, __spreadArray(__spreadArray([], __read(schemaPath), false), ['/items'], false));
        var outputFormat_2 = context.outputFormat;
        var failFast_2 = context.failFast;
        var schemaLocation_2 = schemaPath.join('');
        return function (instance, instanceLocation, annotationResults) {
            if (!(0, isJSONArray_1.isJSONArray)(instance)) {
                return { valid: true, schemaLocation: schemaLocation_2, instanceLocation: instanceLocation };
            }
            var validOutputs = [];
            var invalidIndices = [];
            var errors = [];
            for (var i = 0; i < instance.length; i++) {
                var output = validator_1(instance[i], "".concat(instanceLocation, "/").concat(i));
                if (output.valid) {
                    validOutputs.push(output);
                }
                else {
                    if (failFast_2) {
                        return output;
                    }
                    invalidIndices.push(i);
                    errors.push(output);
                }
            }
            if (errors.length === 0) {
                return {
                    valid: true,
                    schemaLocation: schemaLocation_2,
                    schemaKeyword: 'items',
                    instanceLocation: instanceLocation,
                    annotationResults: {
                        items: validOutputs.length < instance.length ? validOutputs.length - 1 : true
                    }
                };
            }
            else {
                if (outputFormat_2 === 'flag') {
                    return { valid: false };
                }
                else {
                    return {
                        valid: false,
                        schemaLocation: schemaLocation_2,
                        schemaKeyword: 'items',
                        instanceLocation: instanceLocation,
                        message: formatMessage(errors, invalidIndices),
                        errors: errors
                    };
                }
            }
        };
    }
}
exports.itemsValidator = itemsValidator;
function formatMessage(errors, invalidIndices) {
    if (invalidIndices.length === 1) {
        return "has an invalid item at position ".concat(invalidIndices[0], " (").concat(errors[0].message, ")");
    }
    else {
        return "has invalid items at positions ".concat((0, formatList_1.formatList)(invalidIndices.map(function (i) { return "".concat(i); }), 'and'), " (").concat(errors.map(function (error) { return error.message; }).join('; '), ")");
    }
}
exports.formatMessage = formatMessage;
