"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const schemaregistry_client_1 = require("../schemaregistry-client");
const rest_service_1 = require("../rest-service");
const json_stringify_deterministic_1 = __importDefault(require("json-stringify-deterministic"));
const globals_1 = require("@jest/globals");
const test_constants_1 = require("./test-constants");
globals_1.jest.mock('../../schemaregistry/rest-service');
let client;
let restService;
const mockSubject = 'mock-subject';
const mockSubject2 = 'mock-subject2';
const schemaString = (0, json_stringify_deterministic_1.default)({
    type: 'record',
    name: 'User',
    fields: [
        { name: 'name', type: 'string' },
        { name: 'age', type: 'int' }
    ]
});
const schemaString2 = (0, json_stringify_deterministic_1.default)({
    type: 'record',
    name: 'User2',
    fields: [
        { name: 'name2', type: 'string' },
        { name: 'age2', type: 'int' }
    ]
});
const metadata = {
    properties: {
        owner: 'Alice Bob',
        email: 'Alice@bob.com',
    }
};
const metadata2 = {
    properties: {
        owner: 'Alice Bob2',
        email: 'Alice@bob2.com',
    }
};
const metadataKeyValue = {
    'owner': 'Alice Bob',
    'email': 'Alice@bob.com',
};
const metadataKeyValue2 = {
    'owner': 'Alice Bob2',
    'email': 'Alice@bob2.com'
};
const schemaInfo = {
    schema: schemaString,
    schemaType: 'AVRO',
};
const schemaInfo2 = {
    schema: schemaString,
    schemaType: 'AVRO',
};
const schemaInfoMetadata = {
    schema: schemaString,
    schemaType: 'AVRO',
    metadata: metadata,
};
const schemaInfoMetadata2 = {
    schema: schemaString,
    schemaType: 'AVRO',
    metadata: metadata2,
};
const subjects = [mockSubject, mockSubject2];
const versions = [1, 2, 3];
async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
(0, globals_1.describe)('SchemaRegistryClient-Register', () => {
    (0, globals_1.beforeEach)(() => {
        restService = new rest_service_1.RestService(test_constants_1.mockClientConfig.baseURLs);
        client = new schemaregistry_client_1.SchemaRegistryClient(test_constants_1.mockClientConfig);
        client.restService = restService;
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should return id when Register is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: { id: 1 } });
        const response = await client.register(mockSubject, schemaInfo);
        (0, globals_1.expect)(response).toEqual(1);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return from cache when Register is called twice', async () => {
        restService.handleRequest.mockResolvedValue({ data: { id: 1 } });
        const response = await client.register(mockSubject, schemaInfo);
        (0, globals_1.expect)(response).toEqual(1);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
        restService.handleRequest.mockResolvedValue({ data: { id: 2 } });
        const response2 = await client.register(mockSubject2, schemaInfo2);
        (0, globals_1.expect)(response2).toEqual(2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        //Try to create same objects again
        const cachedResponse = await client.register(mockSubject, schemaInfo);
        (0, globals_1.expect)(cachedResponse).toEqual(1);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse2 = await client.register(mockSubject2, schemaInfo2);
        (0, globals_1.expect)(cachedResponse2).toEqual(2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
    (0, globals_1.it)('Should return id, version, metadata, and schema when RegisterFullResponse is called', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.registerFullResponse(mockSubject, schemaInfoMetadata);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return id, version, metadata, and schema from cache when RegisterFullResponse is called twice', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        const expectedResponse2 = {
            id: 2,
            version: 1,
            schema: schemaString2,
            metadata: metadata2,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.registerFullResponse(mockSubject, schemaInfoMetadata);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
        restService.handleRequest.mockResolvedValue({ data: expectedResponse2 });
        const response2 = await client.registerFullResponse(mockSubject2, schemaInfoMetadata2);
        (0, globals_1.expect)(response2).toMatchObject(expectedResponse2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse = await client.registerFullResponse(mockSubject, schemaInfoMetadata);
        (0, globals_1.expect)(cachedResponse).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse2 = await client.registerFullResponse(mockSubject2, schemaInfoMetadata2);
        (0, globals_1.expect)(cachedResponse2).toMatchObject(expectedResponse2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
});
(0, globals_1.describe)('SchemaRegistryClient-Get-ID', () => {
    (0, globals_1.beforeEach)(() => {
        restService = new rest_service_1.RestService(test_constants_1.mockClientConfig.baseURLs);
        client = new schemaregistry_client_1.SchemaRegistryClient(test_constants_1.mockClientConfig);
        client.restService = restService;
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should return id when GetId is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: { id: 1 } });
        const response = await client.getId(mockSubject, schemaInfo);
        (0, globals_1.expect)(response).toEqual(1);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return id from cache when GetId is called twice', async () => {
        restService.handleRequest.mockResolvedValue({ data: { id: 1 } });
        const response = await client.getId(mockSubject, schemaInfo);
        (0, globals_1.expect)(response).toEqual(1);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
        restService.handleRequest.mockResolvedValue({ data: { id: 2 } });
        const response2 = await client.getId(mockSubject2, schemaInfo2);
        (0, globals_1.expect)(response2).toEqual(2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse = await client.getId(mockSubject, schemaInfo);
        (0, globals_1.expect)(cachedResponse).toEqual(1);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse2 = await client.getId(mockSubject2, schemaInfo2);
        (0, globals_1.expect)(cachedResponse2).toEqual(2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
    (0, globals_1.it)('Should return SchemaInfo when GetBySubjectAndId is called', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.getBySubjectAndId(mockSubject, 1);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return SchemaInfo from cache when GetBySubjectAndId is called twice', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        const expectedResponse2 = {
            id: 2,
            version: 1,
            schema: schemaString2,
            metadata: metadata2,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.getBySubjectAndId(mockSubject, 1);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
        restService.handleRequest.mockResolvedValue({ data: expectedResponse2 });
        const response2 = await client.getBySubjectAndId(mockSubject2, 2);
        (0, globals_1.expect)(response2).toMatchObject(expectedResponse2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse = await client.getBySubjectAndId(mockSubject, 1);
        (0, globals_1.expect)(cachedResponse).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse2 = await client.getBySubjectAndId(mockSubject2, 2);
        (0, globals_1.expect)(cachedResponse2).toMatchObject(expectedResponse2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
});
(0, globals_1.describe)('SchemaRegistryClient-Get-Schema-Metadata', () => {
    (0, globals_1.beforeEach)(() => {
        restService = new rest_service_1.RestService(test_constants_1.mockClientConfig.baseURLs);
        client = new schemaregistry_client_1.SchemaRegistryClient(test_constants_1.mockClientConfig);
        client.restService = restService;
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should return latest schema with metadata when GetLatestWithMetadata is called', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.getLatestWithMetadata(mockSubject, metadataKeyValue);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return latest schema with metadata from cache when GetLatestWithMetadata is called twice', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        const expectedResponse2 = {
            id: 2,
            version: 1,
            schema: schemaString2,
            metadata: metadata2,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.getLatestWithMetadata(mockSubject, metadataKeyValue);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
        restService.handleRequest.mockResolvedValue({ data: expectedResponse2 });
        const response2 = await client.getLatestWithMetadata(mockSubject2, metadataKeyValue2);
        (0, globals_1.expect)(response2).toMatchObject(expectedResponse2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse = await client.getLatestWithMetadata(mockSubject, metadataKeyValue);
        (0, globals_1.expect)(cachedResponse).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse2 = await client.getLatestWithMetadata(mockSubject2, metadataKeyValue2);
        (0, globals_1.expect)(cachedResponse2).toMatchObject(expectedResponse2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
    (0, globals_1.it)('Should return SchemaMetadata when GetSchemaMetadata is called', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.getSchemaMetadata(mockSubject, 1, true);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return SchemaMetadata from cache when GetSchemaMetadata is called twice', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        const expectedResponse2 = {
            id: 2,
            version: 1,
            schema: schemaString2,
            metadata: metadata2,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.getSchemaMetadata(mockSubject, 1, true);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
        restService.handleRequest.mockResolvedValue({ data: expectedResponse2 });
        const response2 = await client.getSchemaMetadata(mockSubject2, 2, false);
        (0, globals_1.expect)(response2).toMatchObject(expectedResponse2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse = await client.getSchemaMetadata(mockSubject, 1, true);
        (0, globals_1.expect)(cachedResponse).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse2 = await client.getSchemaMetadata(mockSubject2, 2, false);
        (0, globals_1.expect)(cachedResponse2).toMatchObject(expectedResponse2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
});
(0, globals_1.describe)('SchemaRegistryClient-Subjects', () => {
    (0, globals_1.beforeEach)(() => {
        restService = new rest_service_1.RestService(test_constants_1.mockClientConfig.baseURLs);
        client = new schemaregistry_client_1.SchemaRegistryClient(test_constants_1.mockClientConfig);
        client.restService = restService;
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should return all subjects when GetAllSubjects is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: subjects });
        const response = await client.getAllSubjects();
        (0, globals_1.expect)(response).toEqual(subjects);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return all versions when GetAllVersions is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: versions });
        const response = await client.getAllVersions(mockSubject);
        (0, globals_1.expect)(response).toEqual(versions);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return version when GetVersion is called', async () => {
        const schemaInfo = {
            schema: schemaString,
            schemaType: 'AVRO',
        };
        restService.handleRequest.mockResolvedValue({ data: { version: 1 } });
        const response = await client.getVersion(mockSubject, schemaInfo, true);
        (0, globals_1.expect)(response).toEqual(1);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return version from cache when GetVersion is called twice', async () => {
        const schemaInfo = {
            schema: schemaString,
            schemaType: 'AVRO',
        };
        const schemaInfo2 = {
            schema: schemaString2,
            schemaType: 'AVRO',
        };
        restService.handleRequest.mockResolvedValue({ data: { version: 1 } });
        const response = await client.getVersion(mockSubject, schemaInfo, true);
        (0, globals_1.expect)(response).toEqual(1);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
        restService.handleRequest.mockResolvedValue({ data: { version: 2 } });
        const response2 = await client.getVersion(mockSubject2, schemaInfo2, false);
        (0, globals_1.expect)(response2).toEqual(2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse = await client.getVersion(mockSubject, schemaInfo, true);
        (0, globals_1.expect)(cachedResponse).toEqual(1);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
        const cachedResponse2 = await client.getVersion(mockSubject2, schemaInfo2, false);
        (0, globals_1.expect)(cachedResponse2).toEqual(2);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
    (0, globals_1.it)('Should delete subject from all caches and registry when deleteSubject is called', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        await client.addToInfoToSchemaCache(mockSubject, schemaInfo, expectedResponse);
        await client.addToSchemaToVersionCache(mockSubject, schemaInfo, 1);
        await client.addToVersionToSchemaCache(mockSubject, 1, expectedResponse);
        await client.addToIdToSchemaInfoCache(mockSubject, 1, schemaInfo);
        restService.handleRequest.mockResolvedValue({ data: [1] });
        const response = await client.deleteSubject(mockSubject);
        (0, globals_1.expect)(await client.getInfoToSchemaCacheSize()).toEqual(0);
        (0, globals_1.expect)(await client.getSchemaToVersionCacheSize()).toEqual(0);
        (0, globals_1.expect)(await client.getVersionToSchemaCacheSize()).toEqual(0);
        (0, globals_1.expect)(await client.getIdToSchemaInfoCacheSize()).toEqual(0);
        (0, globals_1.expect)(response).toEqual([1]);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should delete subject version from all caches and registry when deleteSubjectVersion is called', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        await client.addToInfoToSchemaCache(mockSubject, schemaInfo, expectedResponse);
        await client.addToSchemaToVersionCache(mockSubject, schemaInfo, 1);
        await client.addToVersionToSchemaCache(mockSubject, 1, expectedResponse);
        await client.addToIdToSchemaInfoCache(mockSubject, 1, schemaInfo);
        restService.handleRequest.mockResolvedValue({ data: [1] });
        const response = await client.deleteSubjectVersion(mockSubject, 1);
        (0, globals_1.expect)(await client.getVersionToSchemaCacheSize()).toEqual(0);
        (0, globals_1.expect)(await client.getInfoToSchemaCacheSize()).toEqual(0);
        (0, globals_1.expect)(await client.getSchemaToVersionCacheSize()).toEqual(0);
        (0, globals_1.expect)(await client.getIdToSchemaInfoCacheSize()).toEqual(0);
        (0, globals_1.expect)(response).toEqual([1]);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
});
(0, globals_1.describe)('SchemaRegistryClient-Compatibility', () => {
    (0, globals_1.beforeEach)(() => {
        restService = new rest_service_1.RestService(test_constants_1.mockClientConfig.baseURLs);
        client = new schemaregistry_client_1.SchemaRegistryClient(test_constants_1.mockClientConfig);
        client.restService = restService;
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should return compatibility level when GetCompatibility is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: { compatibilityLevel: "BACKWARD" } });
        const response = await client.getCompatibility(mockSubject);
        (0, globals_1.expect)(response).toEqual('BACKWARD');
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should update compatibility level when updateCompatibility is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: { compatibility: 'BACKWARD' } });
        const response = await client.updateCompatibility(mockSubject, schemaregistry_client_1.Compatibility.BACKWARD);
        (0, globals_1.expect)(response).toEqual(schemaregistry_client_1.Compatibility.BACKWARD);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return Compatibility when getDefaultCompatibility is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: { compatibilityLevel: 'BACKWARD' } });
        const response = await client.getDefaultCompatibility();
        (0, globals_1.expect)(response).toEqual(schemaregistry_client_1.Compatibility.BACKWARD);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should update default compatibility level when updateDefaultCompatibility is called', async () => {
        restService.handleRequest.mockResolvedValue({ data: { compatibility: 'BACKWARD' } });
        const response = await client.updateDefaultCompatibility(schemaregistry_client_1.Compatibility.BACKWARD);
        (0, globals_1.expect)(response).toEqual(schemaregistry_client_1.Compatibility.BACKWARD);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
});
(0, globals_1.describe)('SchemaRegistryClient-Config', () => {
    (0, globals_1.beforeEach)(() => {
        restService = new rest_service_1.RestService(test_constants_1.mockClientConfig.baseURLs);
        client = new schemaregistry_client_1.SchemaRegistryClient(test_constants_1.mockClientConfig);
        client.restService = restService;
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should return config when getConfig is called', async () => {
        const expectedResponse = {
            compatibilityLevel: 'BACKWARD',
            alias: 'test-config',
            normalize: true,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.getConfig(mockSubject);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should update config when updateConfig is called', async () => {
        const request = {
            compatibility: schemaregistry_client_1.Compatibility.BACKWARD,
            alias: 'test-config',
            normalize: true,
        };
        const expectedResponse = {
            compatibilityLevel: 'BACKWARD',
            alias: 'test-config',
            normalize: true,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.updateConfig(mockSubject, request);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should return config when getDefaultConfig is called', async () => {
        const expectedResponse = {
            compatibilityLevel: 'BACKWARD',
            alias: 'test-config',
            normalize: true,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.getDefaultConfig();
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
    (0, globals_1.it)('Should update default config when updateDefaultConfig is called', async () => {
        const request = {
            compatibility: schemaregistry_client_1.Compatibility.BACKWARD,
            alias: 'test-config',
            normalize: true,
        };
        const expectedResponse = {
            compatibilityLevel: 'BACKWARD',
            alias: 'test-config',
            normalize: true,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        const response = await client.updateDefaultConfig(request);
        (0, globals_1.expect)(response).toMatchObject(expectedResponse);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(1);
    });
});
(0, globals_1.describe)('SchemaRegistryClient-Cache', () => {
    (0, globals_1.beforeEach)(() => {
        restService = new rest_service_1.RestService(test_constants_1.mockClientConfig.baseURLs);
        client = new schemaregistry_client_1.SchemaRegistryClient(test_constants_1.mockTtlClientConfig);
        client.restService = restService;
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.clearAllMocks();
    });
    (0, globals_1.it)('Should delete cached item after expiry', async () => {
        const expectedResponse = {
            id: 1,
            version: 1,
            schema: schemaString,
            metadata: metadata,
        };
        restService.handleRequest.mockResolvedValue({ data: expectedResponse });
        await client.register(mockSubject, schemaInfo);
        await sleep(2000);
        await client.register(mockSubject, schemaInfo);
        (0, globals_1.expect)(restService.handleRequest).toHaveBeenCalledTimes(2);
    });
});
