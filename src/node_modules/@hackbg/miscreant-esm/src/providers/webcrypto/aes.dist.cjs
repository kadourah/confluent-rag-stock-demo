"use strict";
var __awaiter = this && this.__awaiter || (function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
});
Object.defineProperty(exports, "__esModule", {
  value: true
});
const block_1 = require("../../internals/block.dist.cjs");
class WebCryptoAes {
  static importKey(crypto, keyData) {
    return __awaiter(this, void 0, void 0, function* () {
      if (keyData.length !== 16 && keyData.length !== 32) {
        throw new Error(`Miscreant: invalid key length: ${keyData.length} (expected 16 or 32 bytes)`);
      }
      const key = yield crypto.subtle.importKey("raw", keyData, "AES-CBC", false, ["encrypt"]);
      return new WebCryptoAes(crypto, key);
    });
  }
  constructor(_crypto, _key) {
    this._crypto = _crypto;
    this._key = _key;
    this._iv = new block_1.default();
    this._emptyPromise = Promise.resolve(this);
  }
  clear() {
    return this;
  }
  encryptBlock(block) {
    return __awaiter(this, void 0, void 0, function* () {
      const params = {
        name: "AES-CBC",
        iv: this._iv.data
      };
      const ctBlock = yield this._crypto.subtle.encrypt(params, this._key, block.data);
      block.data.set(new Uint8Array(ctBlock, 0, block_1.default.SIZE));
      return this._emptyPromise;
    });
  }
}
exports.default = WebCryptoAes;
