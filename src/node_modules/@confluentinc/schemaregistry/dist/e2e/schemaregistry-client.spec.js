"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schemaregistry_client_1 = require("../schemaregistry-client");
const globals_1 = require("@jest/globals");
const test_constants_1 = require("../test/test-constants");
const uuid_1 = require("uuid");
/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
let schemaRegistryClient;
const testSubject = 'integ-test-subject';
const testServerConfigSubject = 'integ-test-server-config-subject';
const schemaString = JSON.stringify({
    type: 'record',
    name: 'User',
    fields: [
        { name: 'name', type: 'string' },
        { name: 'age', type: 'int' },
    ],
});
const metadata = {
    properties: {
        owner: 'Bob Jones',
        email: 'bob@acme.com',
    },
};
const schemaInfo = {
    schema: schemaString,
    metadata: metadata,
};
const backwardCompatibleSchemaString = JSON.stringify({
    type: 'record',
    name: 'User',
    fields: [
        { name: 'name', type: 'string' },
        { name: 'age', type: 'int' },
        { name: 'email', type: 'string', default: "" },
    ],
});
const backwardCompatibleMetadata = {
    properties: {
        owner: 'Bob Jones2',
        email: 'bob@acme.com',
    },
};
const backwardCompatibleSchemaInfo = {
    schema: backwardCompatibleSchemaString,
    schemaType: 'AVRO',
    metadata: backwardCompatibleMetadata,
};
(0, globals_1.describe)('SchemaRegistryClient Integration Test', () => {
    (0, globals_1.beforeEach)(async () => {
        schemaRegistryClient = new schemaregistry_client_1.SchemaRegistryClient(test_constants_1.clientConfig);
        const subjects = await schemaRegistryClient.getAllSubjects();
        if (subjects && subjects.includes(testSubject)) {
            await schemaRegistryClient.deleteSubject(testSubject);
            await schemaRegistryClient.deleteSubject(testSubject, true);
        }
        if (subjects && subjects.includes(testServerConfigSubject)) {
            await schemaRegistryClient.deleteSubject(testServerConfigSubject);
            await schemaRegistryClient.deleteSubject(testServerConfigSubject, true);
        }
    });
    (0, globals_1.it)("Should return RestError when retrieving non-existent schema", async () => {
        await (0, globals_1.expect)(schemaRegistryClient.getLatestSchemaMetadata((0, uuid_1.v4)())).rejects.toThrow();
    });
    (0, globals_1.it)('Should register, retrieve, and delete a schema', async () => {
        // Register a schema
        const registerResponse = await schemaRegistryClient.registerFullResponse(testSubject, schemaInfo);
        (0, globals_1.expect)(registerResponse).toBeDefined();
        const schemaId = registerResponse?.id;
        const version = registerResponse?.version;
        const getSchemaResponse = await schemaRegistryClient.getBySubjectAndId(testSubject, schemaId);
        (0, globals_1.expect)(getSchemaResponse).toEqual(schemaInfo);
        const getIdResponse = await schemaRegistryClient.getId(testSubject, schemaInfo);
        (0, globals_1.expect)(getIdResponse).toEqual(schemaId);
        // Delete the schema
        const deleteSubjectResponse = await schemaRegistryClient.deleteSubjectVersion(testSubject, version);
        (0, globals_1.expect)(deleteSubjectResponse).toEqual(version);
        const permanentDeleteSubjectResponse = await schemaRegistryClient.deleteSubjectVersion(testSubject, version, true);
        (0, globals_1.expect)(permanentDeleteSubjectResponse).toEqual(version);
    });
    (0, globals_1.it)('Should get all versions and a specific version of a schema', async () => {
        // Register a schema
        const registerResponse = await schemaRegistryClient.registerFullResponse(testSubject, schemaInfo);
        (0, globals_1.expect)(registerResponse).toBeDefined();
        const version = registerResponse?.version;
        const getVersionResponse = await schemaRegistryClient.getVersion(testSubject, schemaInfo);
        (0, globals_1.expect)(getVersionResponse).toEqual(version);
        const allVersionsResponse = await schemaRegistryClient.getAllVersions(testSubject);
        (0, globals_1.expect)(allVersionsResponse).toEqual([version]);
    });
    (0, globals_1.it)('Should get schema metadata', async () => {
        // Register a schema
        const registerResponse = await schemaRegistryClient.registerFullResponse(testSubject, schemaInfo);
        (0, globals_1.expect)(registerResponse).toBeDefined();
        const schemaVersion = registerResponse?.version;
        const registerResponse2 = await schemaRegistryClient.registerFullResponse(testSubject, backwardCompatibleSchemaInfo);
        (0, globals_1.expect)(registerResponse2).toBeDefined();
        const schemaMetadata = {
            id: registerResponse?.id,
            version: schemaVersion,
            schema: schemaInfo.schema,
            subject: testSubject,
            metadata: metadata,
        };
        const schemaMetadata2 = {
            id: registerResponse2?.id,
            version: registerResponse2?.version,
            schema: backwardCompatibleSchemaInfo.schema,
            subject: testSubject,
            metadata: backwardCompatibleMetadata,
        };
        const getLatestMetadataResponse = await schemaRegistryClient.getLatestSchemaMetadata(testSubject);
        (0, globals_1.expect)(schemaMetadata2).toEqual(getLatestMetadataResponse);
        const getMetadataResponse = await schemaRegistryClient.getSchemaMetadata(testSubject, schemaVersion);
        (0, globals_1.expect)(schemaMetadata).toEqual(getMetadataResponse);
        const keyValueMetadata = {
            'owner': 'Bob Jones',
            'email': 'bob@acme.com'
        };
        const getLatestWithMetadataResponse = await schemaRegistryClient.getLatestWithMetadata(testSubject, keyValueMetadata);
        (0, globals_1.expect)(schemaMetadata).toEqual(getLatestWithMetadataResponse);
    });
    (0, globals_1.it)('Should test compatibility for a version and subject, getting and updating', async () => {
        const registerResponse = await schemaRegistryClient.registerFullResponse(testSubject, schemaInfo);
        (0, globals_1.expect)(registerResponse).toBeDefined();
        const version = registerResponse?.version;
        const updateCompatibilityResponse = await schemaRegistryClient.updateCompatibility(testSubject, schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
        (0, globals_1.expect)(updateCompatibilityResponse).toEqual(schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
        const getCompatibilityResponse = await schemaRegistryClient.getCompatibility(testSubject);
        (0, globals_1.expect)(getCompatibilityResponse).toEqual(schemaregistry_client_1.Compatibility.BACKWARD_TRANSITIVE);
        const testSubjectCompatibilityResponse = await schemaRegistryClient.testSubjectCompatibility(testSubject, backwardCompatibleSchemaInfo);
        (0, globals_1.expect)(testSubjectCompatibilityResponse).toEqual(true);
        const testCompatibilityResponse = await schemaRegistryClient.testCompatibility(testSubject, version, backwardCompatibleSchemaInfo);
        (0, globals_1.expect)(testCompatibilityResponse).toEqual(true);
    });
    (0, globals_1.it)('Should update and get default compatibility', async () => {
        const updateDefaultCompatibilityResponse = await schemaRegistryClient.updateDefaultCompatibility(schemaregistry_client_1.Compatibility.FULL);
        (0, globals_1.expect)(updateDefaultCompatibilityResponse).toEqual(schemaregistry_client_1.Compatibility.FULL);
        const getDefaultCompatibilityResponse = await schemaRegistryClient.getDefaultCompatibility();
        (0, globals_1.expect)(getDefaultCompatibilityResponse).toEqual(schemaregistry_client_1.Compatibility.FULL);
    });
    (0, globals_1.it)('Should update and get subject Config', async () => {
        const subjectConfigRequest = {
            compatibility: schemaregistry_client_1.Compatibility.FULL,
            normalize: true
        };
        const subjectConfigResponse = {
            compatibilityLevel: schemaregistry_client_1.Compatibility.FULL,
            normalize: true
        };
        const registerResponse = await schemaRegistryClient.registerFullResponse(testServerConfigSubject, schemaInfo);
        (0, globals_1.expect)(registerResponse).toBeDefined();
        const updateConfigResponse = await schemaRegistryClient.updateConfig(testServerConfigSubject, subjectConfigRequest);
        (0, globals_1.expect)(updateConfigResponse).toBeDefined();
        const getConfigResponse = await schemaRegistryClient.getConfig(testServerConfigSubject);
        (0, globals_1.expect)(getConfigResponse).toEqual(subjectConfigResponse);
    });
    (0, globals_1.it)('Should get and set default Config', async () => {
        const serverConfigRequest = {
            compatibility: schemaregistry_client_1.Compatibility.FULL,
            normalize: false
        };
        const serverConfigResponse = {
            compatibilityLevel: schemaregistry_client_1.Compatibility.FULL,
            normalize: false
        };
        const updateDefaultConfigResponse = await schemaRegistryClient.updateDefaultConfig(serverConfigRequest);
        (0, globals_1.expect)(updateDefaultConfigResponse).toBeDefined();
        const getDefaultConfigResponse = await schemaRegistryClient.getDefaultConfig();
        (0, globals_1.expect)(getDefaultConfigResponse).toEqual(serverConfigResponse);
    });
});
