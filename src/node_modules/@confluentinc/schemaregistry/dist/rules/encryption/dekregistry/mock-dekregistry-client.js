"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockDekRegistryClient = void 0;
const constants_1 = require("./constants");
const json_stringify_deterministic_1 = __importDefault(require("json-stringify-deterministic"));
const rest_error_1 = require("../../../rest-error");
class MockDekRegistryClient {
    constructor() {
        this.kekCache = new Map();
        this.dekCache = new Map();
    }
    async registerKek(name, kmsType, kmsKeyId, shared, kmsProps, doc) {
        const cacheKey = (0, json_stringify_deterministic_1.default)({ name, deleted: false });
        const cachedKek = this.kekCache.get(cacheKey);
        if (cachedKek) {
            return cachedKek;
        }
        const kek = {
            name,
            kmsType,
            kmsKeyId,
            ...kmsProps && { kmsProps },
            ...doc && { doc },
            shared
        };
        this.kekCache.set(cacheKey, kek);
        return kek;
    }
    async getKek(name, deleted = false) {
        const cacheKey = (0, json_stringify_deterministic_1.default)({ name, deleted });
        const cachedKek = this.kekCache.get(cacheKey);
        if (cachedKek && (!cachedKek.deleted || deleted)) {
            return cachedKek;
        }
        throw new rest_error_1.RestError(`Kek not found: ${name}`, 404, 40400);
    }
    async registerDek(kekName, subject, algorithm, version = 1, encryptedKeyMaterial) {
        const cacheKey = (0, json_stringify_deterministic_1.default)({ kekName, subject, version, algorithm, deleted: false });
        const cachedDek = this.dekCache.get(cacheKey);
        if (cachedDek) {
            return cachedDek;
        }
        const dek = {
            kekName,
            subject,
            algorithm,
            ...encryptedKeyMaterial && { encryptedKeyMaterial },
            version,
            ts: constants_1.MOCK_TS
        };
        this.dekCache.set(cacheKey, dek);
        return dek;
    }
    async getDek(kekName, subject, algorithm, version = 1, deleted = false) {
        if (version === -1) {
            let latestVersion = 0;
            for (const key of this.dekCache.keys()) {
                const parsedKey = JSON.parse(key);
                if (parsedKey.kekName === kekName && parsedKey.subject === subject
                    && parsedKey.algorithm === algorithm && parsedKey.deleted === deleted) {
                    latestVersion = Math.max(latestVersion, parsedKey.version);
                }
            }
            if (latestVersion === 0) {
                throw new rest_error_1.RestError(`Dek not found: ${subject}`, 404, 40400);
            }
            version = latestVersion;
        }
        const cacheKey = (0, json_stringify_deterministic_1.default)({ kekName, subject, version, algorithm, deleted: false });
        const cachedDek = this.dekCache.get(cacheKey);
        if (cachedDek) {
            return cachedDek;
        }
        throw new rest_error_1.RestError(`Dek not found: ${subject}`, 404, 40400);
    }
    async close() {
        return;
    }
}
exports.MockDekRegistryClient = MockDekRegistryClient;
