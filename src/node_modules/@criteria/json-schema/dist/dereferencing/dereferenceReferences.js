"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
exports.__esModule = true;
exports.dereferenceReferences = void 0;
var json_pointer_1 = require("@criteria/json-pointer");
var uri_1 = require("../util/uri");
function dereferenceReferences(rootObject, references, index, merge) {
    var dereferencedValues = new Map();
    references.forEach(function (info, reference) {
        var dereferencedValue = index.find(info.resolvedURI, { followReferences: true });
        dereferencedValues.set(reference, dereferencedValue);
    });
    var mergeStaticReference = function (info, reference, dereferencedValue) {
        var parent = info.parent, key = info.key;
        // detect $ref to self
        if (reference === dereferencedValue) {
            delete reference['$ref'];
            if (parent) {
                parent[key] = reference;
            }
            return reference;
        }
        if (parent === null) {
            parent = reference;
            key = '$ref';
        }
        // simple dereference
        if (Object.keys(reference).length === 1) {
            parent[key] = dereferencedValue;
            return dereferencedValue;
        }
        // $ref has siblings
        // dereferencedValue will be discarded and a new object contructed with the merged keywords
        // check that no other references have a dependency on dereferencedValue as the parent
        references.forEach(function (otherInfo, otherReference) {
            if (otherReference === reference) {
                return;
            }
            if (dereferencedValue === otherInfo.parent) {
                if (info.key === 'pet' && info.parent.name !== undefined) {
                    mergeAnyReference(otherInfo, otherReference);
                }
            }
        });
        // $ref has siblings
        // const { $ref, ...siblings } = reference
        var target = merge(reference, info, dereferencedValue);
        // const target = {}
        // mergeReferenceInto(info.metadata?.metaSchemaID)(target, dereferencedValue, siblings, options.referenceMergePolicy)
        parent[key] = target;
        dereferencedValues.set(reference, target);
        return target;
    };
    // replace dynamic anchors with outermost value
    var mergeDynamicReference = function (info, reference, dereferencedValue) {
        var e_1, _a;
        var _b, _c, _d;
        if (!('$dynamicRef' in reference)) {
            return;
        }
        var resolvedURI = info.resolvedURI, parent = info.parent, key = info.key, path = info.path;
        var outermost = rootObject;
        try {
            for (var _e = __values(__spreadArray([''], __read(path), false)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var jsonPointer = _f.value;
                outermost =
                    jsonPointer === '/$ref' && !('$ref' in outermost) ? outermost : (0, json_pointer_1.evaluateJSONPointer)(jsonPointer, outermost);
                if (typeof outermost === 'object' &&
                    '$dynamicAnchor' in outermost &&
                    outermost.$dynamicAnchor === dereferencedValue.$dynamicAnchor) {
                    dereferencedValue = outermost;
                    break;
                }
                if (typeof outermost === 'object' && '$id' in outermost) {
                    var outermostBaseURI = (_c = (_b = index.infoForIndexedObject(outermost)) === null || _b === void 0 ? void 0 : _b.baseURI) !== null && _c !== void 0 ? _c : (_d = index.infoForIndexedObject(rootObject)) === null || _d === void 0 ? void 0 : _d.baseURI;
                    var outermostURI = (0, uri_1.resolveURIReference)(outermost.$id, outermostBaseURI);
                    var anchorURI = (0, uri_1.resolveURIReference)("#".concat(dereferencedValue.$dynamicAnchor), outermostURI);
                    var outermostAnchor = index.find(anchorURI, { followReferences: false });
                    if (outermostAnchor) {
                        dereferencedValue = outermostAnchor;
                        break;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e["return"])) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        parent[key] = dereferencedValue;
    };
    var seen = new Set();
    var mergeAnyReference = function (info, reference) {
        if (seen.has(reference)) {
            return;
        }
        seen.add(reference);
        if (!('$ref' in reference) && !('$dynamicRef' in reference)) {
            return; // already dereferenced
        }
        var dereferencedValue = dereferencedValues.get(reference); // index.find(info.resolvedURI, { followReferences: true })
        // detect chains
        if (references.has(dereferencedValue)) {
            mergeAnyReference(references.get(dereferencedValue), dereferencedValue);
            // update dereferenced value
            dereferencedValue = dereferencedValues.get(dereferencedValue);
        }
        if (info.isDynamic) {
            mergeDynamicReference(info, reference, dereferencedValue);
        }
        else {
            mergeStaticReference(info, reference, dereferencedValue);
        }
    };
    // merge $ref into parent
    references.forEach(mergeAnyReference);
}
exports.dereferenceReferences = dereferenceReferences;
