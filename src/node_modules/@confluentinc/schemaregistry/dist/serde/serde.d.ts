import { Client, Rule, RuleMode, RuleSet, SchemaInfo, SchemaMetadata } from "../schemaregistry-client";
import { RuleRegistry } from "./rule-registry";
import { ClientConfig } from "../rest-service";
export declare enum SerdeType {
    KEY = "KEY",
    VALUE = "VALUE"
}
export declare const MAGIC_BYTE: Buffer<ArrayBuffer>;
/**
 * SerializationError represents a serialization error
 */
export declare class SerializationError extends Error {
    constructor(message?: string);
}
export interface SerdeConfig {
    useLatestVersion?: boolean;
    useLatestWithMetadata?: {
        [key: string]: string;
    };
    cacheCapacity?: number;
    cacheLatestTtlSecs?: number;
    ruleConfig?: {
        [key: string]: string;
    };
    subjectNameStrategy?: SubjectNameStrategyFunc;
}
export type RefResolver = (client: Client, info: SchemaInfo) => Promise<Map<string, string>>;
/**
 * Serde represents a serializer/deserializer
 */
export declare abstract class Serde {
    client: Client;
    serdeType: SerdeType;
    conf: SerdeConfig;
    fieldTransformer: FieldTransformer | null;
    ruleRegistry: RuleRegistry;
    protected constructor(client: Client, serdeType: SerdeType, conf: SerdeConfig, ruleRegistry?: RuleRegistry);
    abstract config(): SerdeConfig;
    close(): void;
    subjectName(topic: string, info?: SchemaInfo): string;
    resolveReferences(client: Client, schema: SchemaInfo, deps: Map<string, string>, format?: string): Promise<void>;
    executeRules(subject: string, topic: string, ruleMode: RuleMode, source: SchemaInfo | null, target: SchemaInfo | null, msg: any, inlineTags: Map<string, Set<string>> | null): Promise<any>;
    getOnSuccess(rule: Rule): string | undefined;
    getOnFailure(rule: Rule): string | undefined;
    isDisabled(rule: Rule): boolean | undefined;
    runAction(ctx: RuleContext, ruleMode: RuleMode, rule: Rule, action: string | undefined, msg: any, err: Error | null, defaultAction: string): Promise<void>;
    getRuleActionName(rule: Rule, ruleMode: RuleMode, actionName: string | undefined): string | null;
    getRuleAction(ctx: RuleContext, actionName: string): RuleAction | undefined;
}
/**
 * SerializerConfig represents a serializer configuration
 */
export interface SerializerConfig extends SerdeConfig {
    autoRegisterSchemas?: boolean;
    useSchemaId?: number;
    normalizeSchemas?: boolean;
}
/**
 * Serializer represents a serializer
 */
export declare abstract class Serializer extends Serde {
    protected constructor(client: Client, serdeType: SerdeType, conf: SerializerConfig, ruleRegistry?: RuleRegistry);
    config(): SerializerConfig;
    /**
     * Serialize serializes a message
     * @param topic - the topic
     * @param msg - the message
     */
    abstract serialize(topic: string, msg: any): Promise<Buffer>;
    getId(topic: string, msg: any, info?: SchemaInfo, format?: string): Promise<[number, SchemaInfo]>;
    writeBytes(id: number, msgBytes: Buffer): Buffer;
}
/**
 * DeserializerConfig represents a deserializer configuration
 */
export type DeserializerConfig = SerdeConfig;
/**
 * Migration represents a migration
 */
export interface Migration {
    ruleMode: RuleMode;
    source: SchemaMetadata | null;
    target: SchemaMetadata | null;
}
/**
 * Deserializer represents a deserializer
 */
export declare abstract class Deserializer extends Serde {
    protected constructor(client: Client, serdeType: SerdeType, conf: DeserializerConfig, ruleRegistry?: RuleRegistry);
    config(): DeserializerConfig;
    /**
     * Deserialize deserializes a message
     * @param topic - the topic
     * @param payload - the payload
     */
    abstract deserialize(topic: string, payload: Buffer): Promise<any>;
    getSchema(topic: string, payload: Buffer, format?: string): Promise<SchemaInfo>;
    getReaderSchema(subject: string, format?: string): Promise<SchemaMetadata | null>;
    hasRules(ruleSet: RuleSet, mode: RuleMode): boolean;
    checkRules(rules: Rule[] | undefined, filter: (ruleMode: RuleMode) => boolean): boolean;
    getMigrations(subject: string, sourceInfo: SchemaInfo, target: SchemaMetadata, format?: string): Promise<Migration[]>;
    getSchemasBetween(subject: string, first: SchemaMetadata, last: SchemaMetadata, format?: string): Promise<SchemaMetadata[]>;
    executeMigrations(migrations: Migration[], subject: string, topic: string, msg: any): Promise<any>;
}
/**
 * SubjectNameStrategyFunc determines the subject from the given parameters
 */
export type SubjectNameStrategyFunc = (topic: string, serdeType: SerdeType, schema?: SchemaInfo) => string;
/**
 * TopicNameStrategy creates a subject name by appending -[key|value] to the topic name.
 * @param topic - the topic name
 * @param serdeType - the serde type
 */
export declare const TopicNameStrategy: SubjectNameStrategyFunc;
/**
 * RuleContext represents a rule context
 */
export declare class RuleContext {
    source: SchemaInfo | null;
    target: SchemaInfo;
    subject: string;
    topic: string;
    isKey: boolean;
    ruleMode: RuleMode;
    rule: Rule;
    index: number;
    rules: Rule[];
    inlineTags: Map<string, Set<string>> | null;
    fieldTransformer: FieldTransformer;
    private fieldContexts;
    constructor(source: SchemaInfo | null, target: SchemaInfo, subject: string, topic: string, isKey: boolean, ruleMode: RuleMode, rule: Rule, index: number, rules: Rule[], inlineTags: Map<string, Set<string>> | null, fieldTransformer: FieldTransformer);
    getParameter(name: string): string | null;
    getInlineTags(name: string): Set<string>;
    currentField(): FieldContext | null;
    enterField(containingMessage: any, fullName: string, name: string, fieldType: FieldType, tags: Set<string> | null): FieldContext;
    getTags(fullName: string): Set<string>;
    leaveField(): void;
}
export interface RuleBase {
    configure(clientConfig: ClientConfig, config: Map<string, string>): void;
    type(): string;
    close(): void;
}
/**
 * RuleExecutor represents a rule executor
 */
export interface RuleExecutor extends RuleBase {
    transform(ctx: RuleContext, msg: any): Promise<any>;
}
/**
 * FieldTransformer represents a field transformer
 */
export type FieldTransformer = (ctx: RuleContext, fieldTransform: FieldTransform, msg: any) => any;
/**
 * FieldTransform represents a field transform
 */
export interface FieldTransform {
    transform(ctx: RuleContext, fieldCtx: FieldContext, fieldValue: any): Promise<any>;
}
/**
 * FieldRuleExecutor represents a field rule executor
 */
export declare abstract class FieldRuleExecutor implements RuleExecutor {
    config: Map<string, string> | null;
    abstract configure(clientConfig: ClientConfig, config: Map<string, string>): void;
    abstract type(): string;
    abstract newTransform(ctx: RuleContext): FieldTransform;
    transform(ctx: RuleContext, msg: any): Promise<any>;
    abstract close(): void;
}
/**
 * FieldContext represents a field context
 */
export declare class FieldContext {
    containingMessage: any;
    fullName: string;
    name: string;
    type: FieldType;
    tags: Set<string>;
    constructor(containingMessage: any, fullName: string, name: string, fieldType: FieldType, tags: Set<string>);
    isPrimitive(): boolean;
    typeName(): string;
}
export declare enum FieldType {
    RECORD = "RECORD",
    ENUM = "ENUM",
    ARRAY = "ARRAY",
    MAP = "MAP",
    COMBINED = "COMBINED",
    FIXED = "FIXED",
    STRING = "STRING",
    BYTES = "BYTES",
    INT = "INT",
    LONG = "LONG",
    FLOAT = "FLOAT",
    DOUBLE = "DOUBLE",
    BOOLEAN = "BOOLEAN",
    NULL = "NULL"
}
/**
 * RuleAction represents a rule action
 */
export interface RuleAction extends RuleBase {
    run(ctx: RuleContext, msg: any, err: Error | null): Promise<void>;
}
/**
 * ErrorAction represents an error action
 */
export declare class ErrorAction implements RuleAction {
    configure(clientConfig: ClientConfig, config: Map<string, string>): void;
    type(): string;
    run(ctx: RuleContext, msg: any, err: Error): Promise<void>;
    close(): void;
}
/**
 * NoneAction represents a no-op action
 */
export declare class NoneAction implements RuleAction {
    configure(clientConfig: ClientConfig, config: Map<string, string>): void;
    type(): string;
    run(ctx: RuleContext, msg: any, err: Error): Promise<void>;
    close(): void;
}
/**
 * RuleError represents a rule error
 */
export declare class RuleError extends Error {
    /**
     * Creates a new rule error.
     * @param message - The error message.
     */
    constructor(message?: string);
}
/**
 * RuleConditionError represents a rule condition error
 */
export declare class RuleConditionError extends RuleError {
    rule: Rule;
    /**
     * Creates a new rule condition error.
     * @param rule - The rule.
     */
    constructor(rule: Rule);
    static error(rule: Rule): string;
}
