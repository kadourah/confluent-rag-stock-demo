import { IBlockCipher, ICryptoProvider, IMACLike } from "../interfaces.dist";
import Block from "../internals/block.dist";
/**
 * AES-PMAC message authentication code
 *
 * Uses a non-constant-time (lookup table-based) software AES implementation.
 * See soft/aes.ts for more information on the security impact.
 */
export declare class PMAC implements IMACLike {
    /** Create a new CMAC instance from the given key */
    static importKey(provider: ICryptoProvider, keyData: Uint8Array): Promise<PMAC>;
    /** The block cipher we're using (i.e. AES-128 or AES-256) */
    private _cipher;
    /** L is computed as described above, for up to PRECOMPUTED_BLOCKS */
    private _L;
    /**
     * L(-1) is computed as described above, and is XORed into the tag in the
     * event the message length is a multiple of the block size
     */
    private _LInv;
    /** buffer is input plaintext, which we process a block-at-a-time */
    private _buffer;
    /** bufferPos marks the end of plaintext in the buffer */
    private _bufferPos;
    /** counter is the number of blocks we have MAC'd so far */
    private _counter;
    /** offset is a block counter-specific tweak to the MAC value */
    private _offset;
    /** tag is the PMAC tag-in-progress */
    private _tag;
    /**
     * finished is set true when we are done processing a message, and forbids
     * any subsequent writes until we reset the internal state
     */
    private _finished;
    constructor(cipher: IBlockCipher, l: Block[], lInv: Block);
    reset(): this;
    clear(): void;
    update(data: Uint8Array): Promise<this>;
    finish(): Promise<Uint8Array>;
    private _processBuffer;
}
