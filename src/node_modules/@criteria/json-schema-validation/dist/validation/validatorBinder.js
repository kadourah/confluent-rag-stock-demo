"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
exports.__esModule = true;
exports.boundValidatorForSchemaKeyword = exports.validatorBinder = void 0;
var json_schema_1 = require("@criteria/json-schema");
var annotationResultsReducerForMetaSchemaID_1 = require("./annotationResultsReducerForMetaSchemaID");
var booleanValidator_1 = require("./booleanValidator");
function validatorBinder(index, _a) {
    var outputFormat = _a.outputFormat, failFast = _a.failFast, validatorsForMetaSchemaID = _a.validatorsForMetaSchemaID;
    // TODO: ignore cache for dynamic
    var cache = new Map();
    var validatorInfoForSchema = function (schema, schemaPath) {
        if (typeof schema === 'boolean') {
            return {
                validator: (0, booleanValidator_1.booleanValidator)(schema, schemaPath, { outputFormat: outputFormat }),
                isDynamic: false
            };
        }
        if (cache.has(schema)) {
            return {
                validator: cache.get(schema),
                isDynamic: false
            };
        }
        var validator;
        var indirectValidator = function (instance, instanceLocation) {
            return validator(instance, instanceLocation);
        };
        cache.set(schema, indirectValidator);
        var metaSchemaID = index.infoForIndexedObject(schema).metadata.metaSchemaID;
        var vocabularyValidators = validatorsForMetaSchemaID(metaSchemaID);
        var annotationResultsReducer = (0, annotationResultsReducerForMetaSchemaID_1.annotationResultsReducerForMetaSchemaID)(metaSchemaID);
        var isChildDynamic = false;
        var validatorForSchema = function (schema, schemaPath) {
            var _a = validatorInfoForSchema(schema, schemaPath), validator = _a.validator, isDynamic = _a.isDynamic;
            isChildDynamic = isDynamic;
            return validator;
        };
        // draft 04/06/07: ref overrides any sibling keywords
        var keywordsFilter = (metaSchemaID === json_schema_1.metaSchemaIDDraft04 ||
            metaSchemaID === json_schema_1.metaSchemaIDDraft06 ||
            metaSchemaID === json_schema_1.metaSchemaIDDraft07) &&
            '$ref' in schema
            ? function (keyword) { return keyword === '$ref'; }
            : function (keyword) { return true; };
        var boundKeywordValidators = Object.entries(vocabularyValidators)
            .filter(function (_a) {
            var _b = __read(_a, 2), keyword = _b[0], vocabularyValidator = _b[1];
            return keywordsFilter(keyword);
        })
            .map(function (_a) {
            var _b = __read(_a, 2), keyword = _b[0], vocabularyValidator = _b[1];
            return boundValidatorForSchemaKeyword(schema, schemaPath, keyword, vocabularyValidator, {
                outputFormat: outputFormat,
                failFast: failFast,
                validatorForSchema: validatorForSchema,
                index: index
            });
        })
            .filter(function (validator) { return typeof validator === 'function'; });
        var schemaLocation = schemaPath.join('');
        if (outputFormat === 'flag') {
            validator = function (instance, instanceLocation) {
                var e_1, _a;
                var _b;
                var outputs = [];
                var accumulatedAnnotationResults = {};
                try {
                    for (var boundKeywordValidators_1 = __values(boundKeywordValidators), boundKeywordValidators_1_1 = boundKeywordValidators_1.next(); !boundKeywordValidators_1_1.done; boundKeywordValidators_1_1 = boundKeywordValidators_1.next()) {
                        var boundKeywordValidator = boundKeywordValidators_1_1.value;
                        var output = boundKeywordValidator(instance, instanceLocation, accumulatedAnnotationResults);
                        if (!output.valid && failFast) {
                            return output;
                        }
                        outputs.push(output);
                        if ('annotationResults' in output) {
                            accumulatedAnnotationResults = annotationResultsReducer(accumulatedAnnotationResults, (_b = output.annotationResults) !== null && _b !== void 0 ? _b : {});
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (boundKeywordValidators_1_1 && !boundKeywordValidators_1_1.done && (_a = boundKeywordValidators_1["return"])) _a.call(boundKeywordValidators_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return reduceFlagOutputs(outputs, schemaLocation, instanceLocation, accumulatedAnnotationResults);
            };
        }
        else {
            validator = function (instance, instanceLocation) {
                var e_2, _a;
                var _b;
                var outputs = [];
                var accumulatedAnnotationResults = {};
                try {
                    for (var boundKeywordValidators_2 = __values(boundKeywordValidators), boundKeywordValidators_2_1 = boundKeywordValidators_2.next(); !boundKeywordValidators_2_1.done; boundKeywordValidators_2_1 = boundKeywordValidators_2.next()) {
                        var boundKeywordValidator = boundKeywordValidators_2_1.value;
                        var output = boundKeywordValidator(instance, instanceLocation, accumulatedAnnotationResults);
                        if (!output.valid && failFast) {
                            return output;
                        }
                        outputs.push(output);
                        if ('annotationResults' in output) {
                            accumulatedAnnotationResults = annotationResultsReducer(accumulatedAnnotationResults, (_b = output.annotationResults) !== null && _b !== void 0 ? _b : {});
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (boundKeywordValidators_2_1 && !boundKeywordValidators_2_1.done && (_a = boundKeywordValidators_2["return"])) _a.call(boundKeywordValidators_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return reduceVerboseOutputs(outputs, schemaLocation, instanceLocation, accumulatedAnnotationResults);
            };
        }
        var isDynamic = schemaPath.includes('/$dynamicRef') || isChildDynamic;
        if (isDynamic) {
            cache["delete"](schema);
        }
        else {
            cache.set(schema, indirectValidator);
        }
        return { validator: validator, isDynamic: isDynamic };
    };
    return function (schema, schemaPath) {
        var validator = validatorInfoForSchema(schema, schemaPath).validator;
        return validator;
    };
}
exports.validatorBinder = validatorBinder;
function reduceFlagOutputs(outputs, schemaLocation, instanceLocation, annotationResults) {
    if (outputs.every(function (output) { return output.valid; })) {
        return { valid: true, schemaLocation: schemaLocation, instanceLocation: instanceLocation, annotationResults: annotationResults };
    }
    else {
        return { valid: false };
    }
}
function reduceVerboseOutputs(outputs, schemaLocation, instanceLocation, annotationResults) {
    if (outputs.every(function (output) { return output.valid; })) {
        return {
            valid: true,
            schemaLocation: schemaLocation,
            instanceLocation: instanceLocation,
            annotationResults: annotationResults
        };
    }
    else {
        if (outputs.length === 1) {
            return outputs[0];
        }
        else {
            var errors = outputs.filter(function (output) { return !output.valid; });
            return {
                valid: false,
                schemaLocation: schemaLocation,
                instanceLocation: instanceLocation,
                message: errors.map(function (output) { return output.message; }).join('; '),
                errors: errors
            };
        }
    }
}
function boundValidatorForSchemaKeyword(schema, schemaPath, schemaKeyword, vocabularyValidator, context) {
    if (!(schemaKeyword in schema)) {
        return null;
    }
    return vocabularyValidator(schema, schemaPath, context);
}
exports.boundValidatorForSchemaKeyword = boundValidatorForSchemaKeyword;
